"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GraphQLPersonalizeService = void 0;
const debug_1 = __importDefault(require("../debug"));
const utils_1 = require("../utils");
const cache_client_1 = require("../cache-client");
class GraphQLPersonalizeService {
    /**
     * Fetch personalize data using the Sitecore GraphQL endpoint.
     * @param {GraphQLPersonalizeServiceConfig} config
     */
    constructor(config) {
        this.config = config;
        this.config.timeout = config.timeout || 400;
        this.graphQLClient = this.getGraphQLClient();
        this.cache = this.getCacheClient();
    }
    get query() {
        return /* GraphQL */ `
      query($siteName: String!, $language: String!, $itemPath: String!) {
        layout(site: $siteName, routePath: $itemPath, language: $language) {
          item {
            id
            version
            personalization {
              variantIds
            }
          }
        }
      }
    `;
    }
    /**
     * Get personalize information for a route
     * @param {string} itemPath page route
     * @param {string} language language
     * @param {string} siteName site name
     * @returns {Promise<PersonalizeInfo | undefined>} the personalize information or undefined (if itemPath / language not found)
     */
    getPersonalizeInfo(itemPath, language, siteName) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a;
            debug_1.default.personalize('fetching personalize info for %s %s %s', siteName, itemPath, language);
            const cacheKey = this.getCacheKey(itemPath, language, siteName);
            let data = this.cache.getCacheValue(cacheKey);
            if (!data) {
                try {
                    data = yield this.graphQLClient.request(this.query, {
                        siteName,
                        itemPath,
                        language,
                    });
                    this.cache.setCacheValue(cacheKey, data);
                }
                catch (error) {
                    if ((0, utils_1.isTimeoutError)(error)) {
                        return undefined;
                    }
                    throw error;
                }
            }
            return ((_a = data === null || data === void 0 ? void 0 : data.layout) === null || _a === void 0 ? void 0 : _a.item)
                ? {
                    pageId: data.layout.item.id,
                    variantIds: data.layout.item.personalization.variantIds,
                }
                : undefined;
        });
    }
    /**
     * Gets cache client implementation
     * Override this method if custom cache needs to be used
     * @returns CacheClient instance
     */
    getCacheClient() {
        var _a, _b;
        return new cache_client_1.MemoryCacheClient({
            cacheEnabled: (_a = this.config.cacheEnabled) !== null && _a !== void 0 ? _a : true,
            cacheTimeout: (_b = this.config.cacheTimeout) !== null && _b !== void 0 ? _b : 10,
        });
    }
    getCacheKey(itemPath, language, siteName) {
        return `${siteName}-${itemPath}-${language}`;
    }
    /**
     * Gets a GraphQL client that can make requests to the API. Uses graphql-request as the default
     * library for fetching graphql data (@see GraphQLRequestClient). Override this method if you
     * want to use something else.
     * @returns {GraphQLClient} implementation
     */
    getGraphQLClient() {
        if (!this.config.clientFactory) {
            throw new Error('clientFactory needs to be provided when initializing GraphQL client.');
        }
        return this.config.clientFactory({
            debugger: debug_1.default.personalize,
            fetch: this.config.fetch,
            timeout: this.config.timeout,
        });
    }
}
exports.GraphQLPersonalizeService = GraphQLPersonalizeService;
