/**
 * @param {ComponentRendering | Fields} renderingOrFields the rendering or fields object to extract the field from
 * @param {string} fieldName the name of the field to extract
 * @param {T} [defaultValue] the default value to return if the field is not defined
 * @returns {Field | T} the field value or the default value if the field is not defined
 */
// eslint-disable-next-line no-redeclare
export function getFieldValue(renderingOrFields, fieldName, defaultValue) {
    if (!renderingOrFields || !fieldName) {
        return defaultValue;
    }
    const fields = renderingOrFields;
    const field = fields[fieldName];
    if (field && typeof field.value !== 'undefined') {
        return field.value;
    }
    const rendering = renderingOrFields;
    if (!rendering.fields ||
        !rendering.fields[fieldName] ||
        typeof rendering.fields[fieldName].value === 'undefined') {
        return defaultValue;
    }
    return rendering.fields[fieldName].value;
}
/**
 * Gets rendering definitions in a given child placeholder under a current rendering.
 * @param {ComponentRendering} rendering
 * @param {string} placeholderName
 * @returns {Array<ComponentRendering | HtmlElementRendering>} child placeholder
 */
export function getChildPlaceholder(rendering, placeholderName) {
    if (!rendering ||
        !placeholderName ||
        !rendering.placeholders ||
        !rendering.placeholders[placeholderName]) {
        return [];
    }
    return rendering.placeholders[placeholderName];
}
/**
 * Returns a regular expression pattern for a dynamic placeholder name.
 * @param {string} placeholder Placeholder name with a dynamic segment (e.g. 'main-{*}')
 * @returns Regular expression pattern for the dynamic segment
 */
export const getDynamicPlaceholderPattern = (placeholder) => {
    return new RegExp(`^${placeholder.replace(/\{\*\}+/i, '\\d+')}$`);
};
/**
 * Checks if the placeholder name is dynamic.
 * @param {string} placeholder Placeholder name
 * @returns True if the placeholder name is dynamic
 */
export const isDynamicPlaceholder = (placeholder) => placeholder.indexOf('{*}') !== -1;
/**
 * The default value for an empty Date field.
 * This value is defined as a default one by .NET
 */
export const EMPTY_DATE_FIELD_VALUE = '0001-01-01T00:00:00Z';
/**
 * Determines if the passed in field object's value is empty.
 * @param {GenericFieldValue | Partial<Field>} field the field object.
 * Partial<T> type is used here because _field.value_ could be required or optional for the different field types
 */
export function isFieldValueEmpty(field) {
    const isImageFieldEmpty = (fieldValue) => !fieldValue.src;
    const isFileFieldEmpty = (fieldValue) => !fieldValue.src;
    const isLinkFieldEmpty = (fieldValue) => !fieldValue.href;
    const isDateFieldEmpty = (fieldValue) => {
        if (typeof fieldValue === 'string') {
            return fieldValue === EMPTY_DATE_FIELD_VALUE;
        }
        else {
            return !(typeof (fieldValue === null || fieldValue === void 0 ? void 0 : fieldValue.getMonth) === 'function' &&
                !isNaN(fieldValue === null || fieldValue === void 0 ? void 0 : fieldValue.getMonth()));
        }
    };
    const isEmpty = (fieldValue) => {
        if (fieldValue === null || fieldValue === undefined) {
            return true;
        }
        if (typeof fieldValue === 'object') {
            return (isImageFieldEmpty(fieldValue) &&
                isFileFieldEmpty(fieldValue) &&
                isLinkFieldEmpty(fieldValue) &&
                isDateFieldEmpty(fieldValue));
        }
        else if (typeof fieldValue === 'number' || typeof fieldValue === 'boolean') {
            // Avoid returning true for 0 and false values
            return false;
        }
        else {
            return !fieldValue || isDateFieldEmpty(fieldValue);
        }
    };
    if (!field)
        return true;
    const dynamicField = field;
    if (dynamicField.value !== undefined) {
        return isEmpty(dynamicField.value);
    }
    return isEmpty(field);
}
