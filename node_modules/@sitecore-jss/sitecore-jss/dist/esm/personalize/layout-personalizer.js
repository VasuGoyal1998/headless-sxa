import { HIDDEN_RENDERING_NAME } from '../constants';
import { EditMode, } from './../layout/models';
const transformToHiddenRenderingVariant = (component) => (Object.assign(Object.assign({}, component), { componentName: HIDDEN_RENDERING_NAME, experiences: {} }));
/**
 * Apply personalization to layout data. This will recursively go through all placeholders/components, check experiences nodes and replace default with object from specific experience.
 * @param {LayoutServiceData} layout Layout data
 * @param {string} variantId variant id
 * @param {string[]} [componentVariantIds] component variant ids
 */
export function personalizeLayout(layout, variantId, componentVariantIds) {
    var _a;
    // Add (page-level) variantId to Sitecore context so that it is accessible here
    layout.sitecore.context.variantId = variantId;
    const placeholders = ((_a = layout.sitecore.route) === null || _a === void 0 ? void 0 : _a.placeholders) || {};
    if (Object.keys(placeholders).length === 0) {
        return undefined;
    }
    const metadataEditing = layout.sitecore.context.pageEditing && layout.sitecore.context.editMode === EditMode.Metadata;
    if (placeholders) {
        Object.keys(placeholders).forEach((placeholder) => {
            placeholders[placeholder] = personalizePlaceholder(placeholders[placeholder], [variantId, ...(componentVariantIds || [])], metadataEditing);
        });
    }
    return placeholders;
}
/**
 * @param {Array} components components within placeholder
 * @param {string[]} variantIds variant ids
 * @param {boolean} metadataEditing indicates if page is rendered in metadata edit mode
 * @returns {Array<ComponentRendering | HtmlElementRendering>} components with personalization applied
 */
export function personalizePlaceholder(components, variantIds, metadataEditing) {
    return components
        .map((component) => {
        const rendering = component;
        if (rendering.experiences !== undefined) {
            return personalizeComponent(rendering, variantIds, metadataEditing);
        }
        else if (rendering.placeholders) {
            const placeholders = rendering.placeholders;
            Object.keys(placeholders).forEach((placeholder) => {
                placeholders[placeholder] = personalizePlaceholder(placeholders[placeholder], variantIds, metadataEditing);
            });
        }
        return component;
    })
        .filter(Boolean);
}
/**
 * @param {ComponentRenderingWithExperiences} component component with experiences
 * @param {string[]} variantIds variant ids
 * @param {boolean} metadataEditing indicates if page is rendered in metadata edit mode
 * @returns {ComponentRendering | null} component with personalization applied or null if hidden
 */
export function personalizeComponent(component, variantIds, metadataEditing) {
    // Check if we have a page/component experience matching any of the variants (there should be at most 1)
    const match = Object.keys(component.experiences).find((variantId) => variantIds.includes(variantId));
    const variant = match && component.experiences[match];
    // variant and componentName can be undefined or null
    if (!variant && !component.componentName) {
        // DEFAULT IS HIDDEN
        if (metadataEditing) {
            component = transformToHiddenRenderingVariant(component);
        }
        else {
            return null;
        }
    }
    else if (variant && variant.componentName === null && variant.dataSource === null) {
        // VARIANT IS HIDDEN
        if (metadataEditing) {
            component = transformToHiddenRenderingVariant(component);
        }
        else {
            return null;
        }
    }
    else if (variant) {
        component = variant;
    }
    // remove unused experiences from layout data
    if (component.experiences) {
        component.experiences = {};
    }
    if (!component.placeholders)
        return component;
    Object.keys(component === null || component === void 0 ? void 0 : component.placeholders).forEach((placeholder) => {
        if (component.placeholders) {
            component.placeholders[placeholder] = personalizePlaceholder(component.placeholders[placeholder], variantIds);
        }
    });
    return component;
}
