var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { siteNameError } from '../constants';
import debug from '../debug';
import { MemoryCacheClient } from '../cache-client';
export const REDIRECT_TYPE_301 = 'REDIRECT_301';
export const REDIRECT_TYPE_302 = 'REDIRECT_302';
export const REDIRECT_TYPE_SERVER_TRANSFER = 'SERVER_TRANSFER';
// The default query for request redirects of site
const defaultQuery = /* GraphQL */ `
  query RedirectsQuery($siteName: String!) {
    site {
      siteInfo(site: $siteName) {
        redirects {
          pattern
          target
          redirectType
          isQueryStringPreserved
          locale
        }
      }
    }
  }
`;
/**
 *  The GraphQLRedirectsService class is used to query the JSS redirects using Graphql endpoint
 */
export class GraphQLRedirectsService {
    /**
     * Creates an instance of graphQL redirects service with the provided options
     * @param {GraphQLRedirectsServiceConfig} options instance
     */
    constructor(options) {
        this.options = options;
        this.graphQLClient = this.getGraphQLClient();
        this.cache = this.getCacheClient();
    }
    get query() {
        return defaultQuery;
    }
    /**
     * Fetch an array of redirects from API
     * @param {string} siteName site name
     * @returns Promise<RedirectInfo[]>
     * @throws {Error} if the siteName is empty.
     */
    fetchRedirects(siteName) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b;
            if (!siteName) {
                throw new Error(siteNameError);
            }
            const cacheKey = `redirects-${siteName}`;
            let data = this.cache.getCacheValue(cacheKey);
            if (!data) {
                data = yield this.graphQLClient.request(this.query, {
                    siteName,
                });
                this.cache.setCacheValue(cacheKey, data);
            }
            return ((_b = (_a = data === null || data === void 0 ? void 0 : data.site) === null || _a === void 0 ? void 0 : _a.siteInfo) === null || _b === void 0 ? void 0 : _b.redirects) || [];
        });
    }
    /**
     * Gets a GraphQL client that can make requests to the API. Uses graphql-request as the default
     * library for fetching graphql data (@see GraphQLRequestClient). Override this method if you
     * want to use something else.
     * @returns {GraphQLClient} implementation
     */
    getGraphQLClient() {
        if (!this.options.clientFactory) {
            throw new Error('clientFactory needs to be provided when initializing GraphQL client.');
        }
        return this.options.clientFactory({
            debugger: debug.redirects,
            fetch: this.options.fetch,
        });
    }
    /**
     * Gets cache client implementation
     * Override this method if custom cache needs to be used
     * @returns CacheClient instance
     */
    getCacheClient() {
        var _a, _b;
        return new MemoryCacheClient({
            cacheEnabled: (_a = this.options.cacheEnabled) !== null && _a !== void 0 ? _a : true,
            cacheTimeout: (_b = this.options.cacheTimeout) !== null && _b !== void 0 ? _b : 10,
        });
    }
}
